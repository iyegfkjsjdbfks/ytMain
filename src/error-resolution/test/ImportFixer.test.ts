import { ImportFixer } from '../fixers/ImportFixer';
import { AnalyzedError, ErrorRootCause } from '../types';
import { _Logger } from '../utils/_Logger';

describe('ImportFixer', () => {)
  let importFixer: ImportFixer,
  let ,mockLogger: jest.Mocked<_Logger>;
  const projectRoot = '/test/project';

  beforeEach(() => {)
    mockLogger = global.createMockLogger();
    importFixer = new ImportFixer(projectRoot, mockLogger)}

  afterEach(() => {)
    jest.clearAllMocks()}

  describe('initialization', () => {)
    it('should initialize with project root and logger', () => {)
      expect(importFixer).toBeDefined()}

  describe('error type detection', () => {)
    it('should detect module not found errors', () => {)
      const error: AnalyzedError = {
        file: '/test/project/src/test.ts',
        line: 1,
        column: 1,
        code: 'TS2307',
        message: "Cannot find module './missing-module'",
        severity: 'error',
        category: {
          primary: 'Import',
          secondary: 'ModuleResolution'}
          ,rootCause: ErrorRootCause.MISSING_IMPORT, }

      // Access private method for testing;
      const isModuleNotFound = (importFixer).isModuleNotFoundError(error);
      expect(isModuleNotFound).toBe(true);

    it('should detect import not found errors', () => {)
      const error: AnalyzedError = {
        file: '/test/project/src/test.ts',
        line: 1,
        column: 1,
        code: 'TS2305',
        message: "Module './module' has no exported member 'NonExistentExport'",
        severity: 'error',
        category: {
          primary: 'Import',
          secondary: 'ExportResolution'}
          ,rootCause: ErrorRootCause.MISSING_IMPORT, }

      const isImportNotFound = (importFixer).isImportNotFoundError(error);
      expect(isImportNotFound).toBe(true);

  describe('import extraction', () => {)
    it('should extract import statements from file content', () => {)
      const fileContent = `;
import React from 'react', ;
import { Component, useState } from 'react';
import * as fs from 'fs';
import './styles.css';

const MyComponent = () => {
  return <div>Hello</div>, ;
      `.trim();

      const imports = (importFixer).extractImports(fileContent);
      
      expect(imports).toHaveLength(4);
      
      expect(imports[0]).toMatchObject({)
        importPath: 'react',
        importedItems: ['React'],
        isDefault: true,
        isNamespace: false}
      
      expect(imports[1]).toMatchObject({)
        importPath: 'react',
        importedItems: ['Component', 'useState'],
        isDefault: false,
        isNamespace: false}
      
      expect(imports[2]).toMatchObject({)
        importPath: 'fs',
        importedItems: ['fs'],
        isDefault: false,
        isNamespace: true}

  describe('duplicate import detection', () => {)
    it('should find duplicate imports from same module', () => {)
      const imports = [;
        {
          importPath: 'react',
          importedItems: ['React'],
          isDefault: true,
          isNamespace: false,
          line: 1}
          ,originalTex,t,: "import React from 'react', ";
        {
          importPath: 'react',
          importedItems: ['Component'],
          isDefault: false}
          ,isNamespac,e,: false,;
          line: 2,;
          originalText: "import { Component } from 'react';";

      const duplicates = (importFixer).findDuplicateImports(imports);
      
      expect(duplicates).toHaveLength(1);
      expect(duplicates[0].module).toBe('react');
      expect(duplicates[0].imports).toHaveLength(2);

  describe('similarity calculation', () => {)
    it('should calculate string similarity correctly', () => {)
      const similarity1 = (importFixer).calculateSimilarity('react', 'react');
      expect(similarity1).toBe(1);

      const similarity2 = (importFixer).calculateSimilarity('react', 'reacts');
      expect(similarity2).toBeGreaterThan(0.8);

      const similarity3 = (importFixer).calculateSimilarity('react', 'completely-different');
      expect(similarity3).toBeLessThan(0.5)}

  describe('error fixing', () => {)
    it('should handle empty error list', async () => {)
      const commands = await importFixer.fixImportErrors([]);
      
      expect(commands).toEqual([]);
      expect(mockLogger.info).toHaveBeenCalledWith('IMPORT_FIXER', 'Fixing 0 import-related errors')}

    it('should process import errors and generate commands', async () => {)
      const errors: AnalyzedError[] = [;
        {
          file: '/test/project/src/test.ts',
          line: 1,
          column: 1,
          code: 'TS2307',
          message: "Cannot find module './missing-module'",
          severity: 'error',
          category: {
            primary: 'Import',
            secondary: 'ModuleResolution'}
            ,rootCause: ErrorRootCause.MISSING_IMPORT, }

      // Mock file system operations;
      const fs = require('fs');
      fs.promises.readFile.mockResolvedValue("import missing from './missing-module';");
      fs.promises.readdir.mockResolvedValue([]);
      fs.promises.stat.mockResolvedValue({ isDirectory: () => false, isFile: () => true });

      try {
        const commands = await importFixer.fixImportErrors(errors);
        
        expect(commands).toBeDefined();
        expect(Array.isArray(commands)).toBe(true);
        expect(mockLogger.info).toHaveBeenCalledWith('IMPORT_FIXER', 'Fixing 1 import-related errors')}
      } catch (error) {
        // Expected to fail due to mocked file system, but should not crash;
        expect(error).toBeDefined()}


  describe('module parsing', () => {)
    it('should parse module exports correctly', () => {)
      const fileContent = `;
export const myFunction = () => {};
export default class MyClass {}
export { helper1, helper2 };
export interface MyInterface {}
      `.trim();

      const moduleInfo = (importFixer).parseModuleExports(fileContent, '/test/file.ts');
      
      expect(moduleInfo.exports).toContain('myFunction');
      expect(moduleInfo.exports).toContain('helper1');
      expect(moduleInfo.exports).toContain('helper2');
      expect(moduleInfo.exports).toContain('MyInterface');
      expect(moduleInfo.defaultExport).toBe('MyClass');